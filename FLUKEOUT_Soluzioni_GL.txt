SELETTORI FLUKEOUT (Soluzioni e Spiegazioni)
Gianluca Loddo
-------------------------------------------------------

LIVELLO 1
-------------------------------------------------------
âœ… Soluzione:
plate

ğŸ“˜ Spiegazione elementare:
Scrivendo semplicemente plate diciamo al browser: "Seleziona tutti gli elementi HTML che si chiamano <plate>". Ãˆ come dire "tutti i piatti!"
ğŸ”§ Come funziona:
In questo livello ci sono due elementi <plate /> dentro un <div>. Questi elementi hanno come tipo plate, quindi possiamo selezionarli usando un type selector, 
ovvero semplicemente scrivendo il nome del tag.
ğŸŸ¢ Risultato:
Entrambi i piatti vengono selezionati correttamente, perchÃ© sono entrambi elementi <plate> nel codice HTML.

LIVELLO 2
-------------------------------------------------------
âœ… Soluzione:
bento

ğŸ“˜ Spiegazione elementare:
Scriviamo bento per dire al browser: "Seleziona tutti gli elementi chiamati <bento>". Ãˆ il modo piÃ¹ diretto per prendere tutte le bento box presenti nella pagina.
ğŸ”§ Come funziona:
Nel codice HTML ci sono due elementi <bento /> e un <plate />, tutti figli diretti di un <div>. 
Il type selector bento seleziona tutti e soli gli elementi con quel nome di tag. Non serve aggiungere classi o ID, perchÃ© il nome del tag Ã¨ giÃ  univoco.
ğŸŸ¢ Risultato:
Vengono selezionate entrambe le bento box (una a sinistra e una a destra), mentre il piatto centrale non viene selezionato. 

LIVELLO 3
-------------------------------------------------------
âœ… Soluzione:
#fancy

ğŸ“˜ Spiegazione elementare:
Usiamo il simbolo # per dire: "Voglio l'elemento che ha id="fancy"". Gli ID sono unici, quindi questo selezionerÃ  un solo piatto: quello elegante con il bordo blu.
ğŸ”§ Come funziona:
Nel codice HTML, il primo elemento <plate /> ha un attributo id="fancy". 
Gli ID selector in CSS si scrivono con # seguito dal nome dell'ID (#fancy). 
Questo selettore ignora gli altri <plate /> o <bento />, anche se dello stesso tipo, perchÃ© cerca esattamente quell'ID.
ğŸŸ¢ Risultato:
Viene selezionato solo il piatto con l'ID fancy (quello a sinistra, con il bordo blu). Gli altri elementi non vengono toccati.

LIVELLO 4
-------------------------------------------------------
âœ… Soluzione:
plate apple

ğŸ“˜ Spiegazione elementare:
Scriviamo plate apple per dire: "Voglio selezionare le mele che si trovano sopra un piatto". Ãˆ come dire â€œmele dentro un contenitore di tipo piattoâ€.
ğŸ”§ Come funziona:
Il selettore plate apple Ã¨ un descendant selector, cioÃ¨ seleziona tutti gli elementi <apple> che si trovano dentro (nidificati in qualsiasi profonditÃ ) un elemento <plate>.
Nel codice ci sono due <apple>: uno dentro un <plate>, uno fuori. Questo selettore prende solo quello dentro.
ğŸŸ¢ Risultato:
Viene selezionata solo la mela che si trova sopra il piatto al centro, mentre quella fuori (a destra) non viene toccata.

LIVELLO 5
-------------------------------------------------------
âœ… Soluzione:
#fancy pickle

ğŸ“˜ Spiegazione elementare:
Usiamo #fancy pickle per dire: "Voglio selezionare il pickle che si trova sul piatto con lâ€™ID fancy". Solo quel cetriolino verde, non gli altri!
ğŸ”§ Come funziona:
Il selettore #fancy prende il piatto con id="fancy", e il selettore pickle dopo uno spazio seleziona tutti i pickle discendenti (cioÃ¨ contenuti allâ€™interno) di quellâ€™elemento.
Questo Ã¨ un esempio di combinazione tra ID selector e descendant selector.
ğŸŸ¢ Risultato:
Viene selezionato solo il pickle sul piatto blu con ID fancy, mentre lâ€™altro pickle (sul piatto normale) non viene selezionato.

LIVELLO 6
-------------------------------------------------------
âœ… Soluzione:
.small

ğŸ“˜ Spiegazione elementare:
Usiamo il punto (.) davanti al nome della classe per dire: "Voglio selezionare tutti gli elementi con classe small". Ãˆ come chiedere: â€œMostrami tutte le mele piccole!â€
ğŸ”§ Come funziona:
Nel codice HTML ci sono tre <apple>:
uno normale (senza classe),
due con class="small" (uno fuori dai piatti e uno dentro un piatto).
Il selettore .small prende tutti gli elementi con quella classe, indipendentemente dal tag o dalla posizione.
ğŸŸ¢ Risultato:
Vengono selezionate entrambe le mele piccole, sia quella fuori che quella dentro il piatto. La mela grande a sinistra non viene selezionata.

LIVELLO 7
-------------------------------------------------------
âœ… Soluzione:
orange.small
ğŸ“˜ Spiegazione elementare:
Scrivendo orange.small diciamo: "Seleziona solo gli elementi arancia (orange) che hanno anche la classe small". Non tutte le arance, solo quelle piccole!
ğŸ”§ Come funziona:
Nel codice ci sono tre <orange>:
Uno normale (senza classe),
Due con class="small".
Il selettore orange.small combina il type selector (orange) con il class selector (.small), e funziona solo se entrambi i criteri sono veri. Quindi prende solo le arance che sono piccole.
ğŸŸ¢ Risultato:
Vengono selezionate due arance piccole: una nel bento (sinistra) e una sul piatto (destra). Lâ€™arancia normale (al centro) non viene selezionata.

Approfondimento:
âœ… In CSS (come selettore)
----------------------------------------------------------------

   orange small		<orange><small>...</small></orange>
  -------------- 	-----------------------------------
Selettore discendente.
Seleziona tutti gli elementi <small> dentro un elemento <orange>.

orange small {
  color: red;
}

ğŸ“ Questo colora di rosso tutti i <small> interni a un <orange>.
----------------------------------------------------------------

   orange.small		<orange class="small"></orange>
  -------------- 	------------------------------- 
Selettore con classe.
Seleziona solo gli elementi <orange> che hanno classe small.

orange.small {
  color: red;
}

ğŸ“ Questo colora di rosso solo il tag <orange class="small">.

----------------------------------------------------------------------------------------------
| Scrittura      | Significato                       | Esempio HTML corrispondente           |
| -------------- | --------------------------------- | ------------------------------------- |
| `orange small` | `<small>` **dentro** `<orange>`   | `<orange><small>...</small></orange>` |
| `orange.small` | `<orange>` con **classe `small`** | `<orange class="small"></orange>`     |
----------------------------------------------------------------------------------------------

LIVELLO 8
-------------------------------------------------------
âœ… Soluzione:
bento orange.small

ğŸ“˜ Spiegazione elementare:
Con bento orange.small stiamo dicendo: "Seleziona solo le arance piccole (.small) che si trovano dentro un contenitore bento".
ğŸ”§ Come funziona:
Questo selettore combina:
un type selector (bento) per cercare tutti i contenitori bento,
un descendant selector (spazio) per cercare dentro quei bento,
e un selector combinato orange.small per prendere solo le arance con la classe small.
Nel codice HTML ci sono 5 <bento>:
Uno con arancia normale (non presa),
Tre con arancia piccola (presi),
Uno con mela piccola (non presa).
ğŸŸ¢ Risultato:
Vengono selezionate solo le tre arance piccole che si trovano dentro un bento. Le altre (mela piccola o arancia normale) non vengono selezionate.

LIVELLO 9
-------------------------------------------------------
âœ… Soluzione:
plate, bento

ğŸ“˜ Spiegazione elementare:
Mettiamo una virgola tra i selettori per dire: "Seleziona sia tutti i piatti (plate) che tutti i contenitori bento (bento)". 
Ãˆ un modo per unire piÃ¹ tipi di elementi nella stessa regola.
ğŸ”§ Come funziona:
In CSS, il comma combinator (,) permette di combinare piÃ¹ selettori separati. 
Ogni selettore funziona in modo indipendente e viene applicato a sÃ©. In questo caso:
plate seleziona tutti gli elementi <plate>,
bento seleziona tutti gli elementi <bento>.
Il risultato Ã¨ lâ€™unione di entrambi.
ğŸŸ¢ Risultato:
Vengono selezionati tutti i piatti e tutti i bento presenti sulla tavola. Gli altri elementi (come i cetriolini/pickle) non vengono selezionati.

LIVELLO 10
-------------------------------------------------------
âœ… Soluzione:
*
ğŸ“˜ Spiegazione elementare:
Il simbolo * in CSS significa: "Seleziona tutti gli elementi della pagina". Ãˆ il modo piÃ¹ semplice per dire: â€œPrendili tutti, nessuno escluso!â€
ğŸ”§ Come funziona:
Il selettore * Ã¨ chiamato universal selector.
Non ha bisogno di nomi di tag, classi o ID: prende qualsiasi elemento HTML presente, indipendentemente dal tipo, posizione o attributi.
ğŸŸ¢ Risultato:
Vengono selezionati tutti gli elementi sulla tavola: mele, arance, piatti, bentos, tutto! Nessun elemento rimane escluso.

LIVELLO 11
-------------------------------------------------------
âœ… Soluzione:
plate *
ğŸ“˜ Spiegazione elementare:
Scriviamo plate * per dire: "Seleziona tutti gli elementi che si trovano dentro un piatto". Il simbolo * vuol dire "qualsiasi cosa".
ğŸ”§ Come funziona:
Questo Ã¨ un descendant selector combinato con il universal selector *.
plate seleziona ogni elemento <plate>,
* dopo lo spazio seleziona qualsiasi cosa che si trovi al suo interno (discendenti di ogni tipo: orange, pickle, apple, ecc.).
ğŸŸ¢ Risultato:
Vengono selezionati tutti gli elementi contenuti dentro un piatto, ovvero:
lâ€™arancia piccola nel primo piatto,
il cetriolo nel secondo,
la mela nel terzo.
La mela piccola fuori dal piatto non viene selezionata.

LIVELLO 12 => USO DEL SELETTORE "+"
-------------------------------------------------------
âœ… Soluzione:
plate + apple

ğŸ“˜ Spiegazione elementare:
Con plate + apple diciamo: "Seleziona ogni mela (apple) che si trova subito dopo un piatto (plate)". Solo le mele che vengono immediatamente dopo, non tutte.
ğŸ”§ Come funziona:
Il simbolo + Ã¨ un adjacent sibling selector: seleziona lâ€™elemento B che si trova subito dopo lâ€™elemento A, allo stesso livello (cioÃ¨ â€œfratelliâ€ nel DOM).
In questo caso, seleziona ogni <apple> che Ã¨ sorella immediatamente successiva di un <plate>.
Nel codice:
Il primo <plate> Ã¨ seguito da una mela piccola â†’ âœ”ï¸ selezionata
Il secondo <plate> Ã¨ seguito da una mela grande â†’ âœ”ï¸ selezionata
Le altre mele non seguono direttamente un piatto â†’ âŒ non selezionate
ğŸŸ¢ Risultato:
Vengono selezionate le due mele che stanno subito dopo i piatti. Le mele prima, o che non sono immediatamente accanto a un piatto, non vengono selezionate.

LIVELLO 13 => USO DI "~" (FRATELLI ALLO STESSO LIVELLO)
-------------------------------------------------------
âœ… Soluzione:
bento ~ pickle

ğŸ“˜ Spiegazione elementare:
Con bento ~ pickle si sta dicendo: "Seleziona tutti i cetriolini (pickle) che si trovano dopo un bento, sullo stesso livello (fratelli)".
ğŸ”§ Come funziona:
Il selettore ~ Ã¨ chiamato general sibling selector:
A ~ B seleziona tutti gli elementi B che sono fratelli di A e che vengono dopo A, anche se non immediatamente.
In questo caso, si cerca ogni pickle che segue un bento.
Nel codice:
Il primo pickle viene prima del bento â†’ âŒ non selezionato
Tutti gli altri pickle seguono il bento â†’ âœ”ï¸ selezionati
ğŸŸ¢ Risultato:
Vengono selezionati tutti i cetriolini che si trovano dopo il bento, indipendentemente dalla distanza o da altri elementi in mezzo.

Approfondimento:
âœ… COS'Ã¨ UN "FRATELLO" (SIBLING) IN HTML
----------------------------------------------------------------
!!! Regola chiave !!!
Due elementi sono fratelli solo se stanno alla stessa profonditÃ  nella struttura HTML, cioÃ¨ dentro lo stesso contenitore diretto (genitore).

Ripetendo: in HTML, due elementi sono fratelli (siblings) se sono contenuti nello stesso genitore.
Proprio come due fratelli nella stessa famiglia.

ğŸ“¦ Esempio base:
<div>
  <h1>Benvenuto</h1>
  <p>Questo Ã¨ un paragrafo.</p>
  <p>Questo Ã¨ un altro paragrafo.</p>
</div>

In questo caso:
<h1>, <p>, e <p> sono tutti fratelli perchÃ© hanno lo stesso genitore: il <div>

âœ… Fratelli (sibling)
<div>
  <bento></bento>       â† fratello
  <pickle></pickle>     â† fratello successivo
</div>

Qui si puÃ² usare il selettore: bento ~ pickle
che prende tutti i <pickle> dopo il <bento> nello stesso <div>.

âŒ Non fratelli (non si puÃ² usare ~)
<div>
  <bento>
    <pickle></pickle>  â† questo Ã¨ **dentro** il bento, non fratello!
  </bento>
  <pickle></pickle>     â† questo sÃ¬, Ã¨ un fratello
</div>

In questo caso:
Il primo <pickle> Ã¨ figlio del <bento> â†’ âŒ non Ã¨ fratello
Il secondo <pickle> invece Ã¨ fratello del bento â†’ âœ… valido

LIVELLO 14 => USO DI ">" (FIGLI DIRETTI)
-------------------------------------------------------
âœ… Soluzione:
plate > apple

ğŸ“˜ Spiegazione elementare:
Con plate > apple si sta dicendo: "Seleziona ogni mela (apple) che Ã¨ figlia diretta di un piatto (plate)", 
cioÃ¨ si trova immediatamente al suo interno, senza altri contenitori nel mezzo.
ğŸ”§ Come funziona:
Il simbolo > Ã¨ il child selector e serve a selezionare solo gli elementi figli diretti (e non nipoti o discendenti generici).
Il selettore A > B significa: seleziona gli elementi B che sono figli diretti di A.
Nel codice:
La prima mela Ã¨ dentro un <bento> che Ã¨ dentro un <plate> â†’ âŒ non selezionata (non figlia diretta)
La seconda mela Ã¨ direttamente dentro un <plate> â†’ âœ”ï¸ selezionata
Le altre mele sono fuori da qualsiasi piatto â†’ âŒ non selezionate
ğŸŸ¢ Risultato:
Viene selezionata solo la mela che si trova direttamente sopra un piatto, senza contenitori intermedi. 
Le mele dentro altri contenitori o fuori dai piatti non vengono selezionate.

Approfondimento:
âœ… HTML + CSS (FIGLIO DIRETTO ">")
----------------------------------------------------------------
DIFFERENZE TRA FIGLIO DIRETTO ">" E "DISCENDENTE" (qualsiasi livello di nidificazione, con spazio)

ğŸ“„ Esempio HTML
<div class="piatto">
  <apple></apple> <!-- âœ… Figlio diretto del div -->
  
  <bento>
    <apple></apple> <!-- âŒ NON Ã¨ figlio diretto del div, ma nipote -->
  </bento>
</div>
----------------------------------------------------------------------
âœ… Selettore figlio diretto (>)
.piatto > apple {
  background: green;
}
ğŸ”¹ Questo selettore colora solo lâ€™elemento <apple> che Ã¨ figlio diretto di .piatto
ğŸ”¸ NON colora la mela dentro il <bento>.
----------------------------------------------------------------------
âš ï¸ Selettore discendente (<spazio>)
.piatto apple {
  background: red;
}
ğŸ”¹ Questo selettore colora tutte le mele dentro .piatto, a qualsiasi profonditÃ 
ğŸ”¸ Quindi colora sia la mela fuori che quella dentro il bento.
----------------------------------------------------------------------
| Selettore | Cosa prende                          | Esempio         |
| --------- | ------------------------------------ | --------------- |
| `A > B`   | Solo i figli diretti                 | `plate > apple` |
| `A B`     | Tutti i discendenti (figli, nipotiâ€¦) | `plate apple`   |
----------------------------------------------------------------------

LIVELLO 15 => USO DI ":FIRST-CHILD" (PRIMO FIGLIO)
-------------------------------------------------------
âœ… Soluzione:
plate orange:first-child

ğŸ“˜ Spiegazione elementare:
Con plate orange:first-child si sta dicendo: "Seleziona la prima arancia (orange) che si trova dentro un piatto (plate)". 
In pratica, si vuole prendere lâ€™arancia in cima alla pila.
ğŸ”§ Come funziona:
Il selettore :first-child prende solo il primo figlio di un contenitore.
In questo caso:
plate seleziona i piatti,
orange:first-child prende solo lâ€™arancia che Ã¨ il primo elemento dentro il piatto.
Nel codice:
Il secondo <plate> contiene tre arance.
Solo la prima arancia Ã¨ selezionata, le altre no.
ğŸŸ¢ Risultato:
Viene selezionata solo lâ€™arancia piÃ¹ in alto tra le tre impilate sul piatto a destra. Le altre due non vengono selezionate.

Approfondimento:
âœ… SELETTORE :first-child
----------------------------------------------------------------
Il selettore :first-child seleziona un elemento solo se Ã¨ il primo figlio del proprio genitore.

ğŸ” Esempio 1 â€” Funziona âœ…
<div>
  <orange></orange>   <!-- âœ… Primo figlio -->
  <orange></orange>
</div>

orange:first-child {
  border: 2px solid red;
}
âœ… Il primo <orange> viene selezionato e stilizzato, perchÃ© Ã¨ il primo figlio del <div>.
==============================
ğŸš« Esempio 2 â€” Non funziona âŒ
<div>
  <plate></plate>
  <orange></orange>   <!-- âŒ NON Ã¨ primo figlio (c'Ã¨ il plate prima) -->
</div>

orange:first-child {
  border: 2px solid red;
}
âŒ Il <orange> non viene selezionato perchÃ© Ã¨ il secondo figlio (il primo Ã¨ <plate>).
==============================

ğŸ¥‡ Come combinarlo bene
Es. Qualora si volesse selezionare solo lâ€™arancia prima figlia di un piatto, si dovrebbe scrivere:
plate > orange:first-child
Questo:
prende solo arance (orange) che sono figlie dirette di un piatto (plate >) e sono il primo figlio di quel piatto (:first-child)

ğŸ“„ Esempio completo e funzionante:
<plate>
  <orange></orange>     <!-- âœ… selezionato -->
  <orange></orange>     <!-- âŒ ignorato -->
</plate>

<plate>
  <pickle></pickle>
  <orange></orange>     <!-- âŒ NON Ã¨ primo figlio -->
</plate>

--
plate > orange:first-child {
  background: orange;
}
ğŸ”¹ Risultato: solo la prima arancia nel primo piatto viene selezionata.
----------------------------------------------------------------

LIVELLO 16 => USO DI ":ONLY-CHILD" (UNICO FIGLIO)
-------------------------------------------------------
âœ… Soluzione:
plate :only-child

ğŸ“˜ Spiegazione elementare:
Con plate :only-child si sta dicendo: "Seleziona lâ€™unico elemento presente dentro ogni piatto (plate)". 
In questo caso:
Se in un piatto câ€™Ã¨ solo una mela, verrÃ  selezionata.
Se câ€™Ã¨ solo un cetriolino, anche quello sarÃ  selezionato.
ğŸ”§ Come funziona:
Il pseudo-selettore :only-child seleziona un elemento che Ã¨ lâ€™unico figlio del suo genitore.
plate :only-child 
significa: qualsiasi elemento (non importa che tipo) che sia lâ€™unico figlio dentro un <plate>.
Nel codice:
Il primo piatto contiene solo una mela â†’ âœ”ï¸ selezionata
Il secondo piatto contiene solo un pickle â†’ âœ”ï¸ selezionato
Il quarto piatto contiene due arance â†’ âŒ nessuna selezionata (non sono figli unici)
ğŸŸ¢ Risultato:
Vengono selezionati la mela e il cetriolino che si trovano da soli nei rispettivi piatti.

LIVELLO 17 => USO DI ":LAST-CHILD" (ULTIMO FIGLIO)
-------------------------------------------------------
âœ… Soluzione:
.small:last-child

ğŸ“˜ Spiegazione elementare:
Si sta dicendo: "Seleziona tutti gli elementi con classe small che sono anche lâ€™ultimo figlio dentro il loro contenitore".
ğŸ”§ Come funziona:
.small seleziona tutti gli elementi che hanno la classe small
:last-child restringe la selezione solo a quelli che sono lâ€™ultimo figlio del loro genitore
Nel codice:
Lâ€™apple small nel primo piatto Ã¨ lâ€™unico figlio â†’ Ã¨ anche lâ€™ultimo â†’ âœ”ï¸ selezionato
La seconda orange nel terzo piatto Ã¨ lâ€™ultima, ma non ha la classe small â†’ âŒ
Il pickle small in fondo Ã¨ lâ€™ultimo figlio della tavola e ha la classe small â†’ âœ”ï¸
ğŸŸ¢ Risultato:
Vengono selezionati:
La mela piccola nel primo piatto
Il cetriolo piccolo in fondo al tavolo

Approfondimento:
âœ… SELETTORE :last-child e :last-of-type
----------------------------------------------------------------
ğŸ§ª ESEMPIO BASE: uso di :last-child

ğŸ”§ HTML
<ul>
  <li>Mela</li>
  <li>Banana</li>
  <li>Pera</li> <!-- Questo Ã¨ il last-child -->
</ul>
âœ… CSS con :last-child
li:last-child {
  color: red;
}
ğŸŸ¢ Questo colora solo lâ€™ultimo <li> della lista (cioÃ¨ "Pera").

âš ï¸ ATTENZIONE: non Ã¨ "ultimo elemento del tipo", ma ultimo figlio in assoluto!
âŒ Esempio di errore comune:
<div>
  <p>Paragrafo 1</p>
  <p>Paragrafo 2</p>
  <span>Ultimo elemento</span>
</div>

p:last-child {
  color: blue;
}
ğŸ”´ NON funziona, perchÃ© il secondo <p> non Ã¨ lâ€™ultimo figlio del <div> (câ€™Ã¨ ancora uno <span> dopo).
==============================

âœ… Alternativa: :last-of-type
Se si volesse selezionare lâ€™ultimo <p> tra tutti i paragrafi, indipendentemente da cosa c'Ã¨ dopo:
p:last-of-type {
  color: blue;
}

==============================
ğŸ§  Differenze tra :last-child e :last-of-type
-----------------------------------------------------------------------------------
| Selettore       | Significato                                                   |
| --------------- | ------------------------------------------------------------- |
| `:last-child`   | L'ultimo figlio **in assoluto** di un genitore                |
| `:last-of-type` | L'ultimo elemento **di quel tipo** tra i figli di un genitore |
-----------------------------------------------------------------------------------

LIVELLO 18 => USO DI ":NTH-CHILD( )" (Fratello/Figlio NUMERO "X")
-------------------------------------------------------
âœ… Soluzione:
plate:nth-child(3)

ğŸ“˜ Spiegazione elementare:
Si sta dicendo al browser: â€œSeleziona il terzo elemento plate (piatto) nella lista dei figli del contenitoreâ€.
ğŸ”§ Come funziona:
plate Ã¨ il tipo di elemento che vogliamo selezionare (in questo caso un <plate />)
:nth-child(3) prende solo il terzo figlio allâ€™interno del contenitore, non il terzo plate in assoluto, ma il terzo elemento a prescindere dal tipo
In questo livello, tutti i figli sono <plate />, quindi non ci sono interferenze
ğŸŸ¢ Risultato:
Viene selezionato solo il terzo piatto da sinistra (quello con il bordo blu, evidenziato nel gioco).

Approfondimento:
âœ… SELETTORE :nth-child() e :nth-of-type()
----------------------------------------------------------------
Il selettore :nth-child() Ã¨ uno dei piÃ¹ potenti in CSS, perchÃ© permette di selezionare elementi in base alla loro posizione fra i fratelli, in modo preciso o ricorrente.

âœ… Sintassi base
selettore:nth-child(n)
Seleziona lâ€™elemento che Ã¨ il n-esimo figlio del suo genitore.

ğŸ” Uso dei pattern: odd, even, 2n, 3n+1...

:nth-child(odd)
li:nth-child(odd)
âœ… Seleziona i figli in posizioni dispari (1Â°, 3Â°, 5Â°, ...)

:nth-child(even)
li:nth-child(even)
âœ… Seleziona i figli in posizioni pari (2Â°, 4Â°, 6Â°, ...)

:nth-child(3n)
li:nth-child(3n)
âœ… Seleziona ogni terzo figlio (3Â°, 6Â°, 9Â°, ...)

:nth-child(2n+1)
div:nth-child(2n+1)
âœ… Anche questo equivale a odd â†’ seleziona 1Â°, 3Â°, 5Â°, ecc.

==============================
âš ï¸ ATTENZIONE! Non filtra per tipo di tag!
Questo Ã¨ importantissimo:

<div>
  <h1>Titolo</h1>       <!-- 1Â° -->
  <p>Primo paragrafo</p> <!-- 2Â° -->
  <p>Secondo paragrafo</p> <!-- 3Â° -->
</div>

p:nth-child(2) { color: red; }

âœ… Colora il primo <p>, perchÃ© Ã¨ il secondo figlio del div
âŒ Non colora il secondo <p>, che Ã¨ il terzo figlio

==============================

âœ… Se si volesse filtrare per tipo di tag: usa :NTH-OF-TYPE()

p:nth-of-type(2)

âœ… Seleziona il secondo <p>, indipendentemente dalla posizione generale tra i figli.
--------------------------------------------------------------------
| Selettore         | Significato                                  |
| ----------------- | -------------------------------------------- |
| `:nth-child(n)`   | Il n-esimo **figlio generico**               |
| `:nth-of-type(n)` | Il n-esimo **figlio di quel tipo specifico** |
--------------------------------------------------------------------

LIVELLO 19 => USO DI ":NTH-LAST-CHILD( )" ("n" ULTIMO FIGLIO)
-------------------------------------------------------
âœ… Soluzione:
bento:nth-child(2)

ğŸ“˜ Spiegazione elementare:
Nella struttura HTML del livello, il primo figlio Ã¨ un <plate />.
Il secondo figlio Ã¨ proprio il primo <bento />, quello che devi selezionare.
:nth-child(2) seleziona il secondo elemento figlio nel contenitore, ma solo se Ã¨ un bento (quindi bisogna scrivere bento:nth-child(2) e non solo :nth-child(2)).

ğŸ” Differenza da :nth-last-child(n):
Questo livello Ã¨ un piccolo inganno: pur parlando di :nth-last-child() nella spiegazione a destra, 
in realtÃ  l'elemento da selezionare Ã¨ il primo bento dallâ€™alto, non uno degli ultimi.

Approfondimento:
âœ… SELETTORE :nth-last-child()
----------------------------------------------------------------
:nth-last-child(n) Ã¨ un pseudo-selettore CSS che seleziona uno o piÃ¹ elementi 
in base alla loro posizione contando dalla fine (cioÃ¨ dal basso verso l'alto) tra i figli di un elemento genitore.
ğŸ“Œ Sintassi:
element:nth-last-child(n)

element: Ã¨ il tipo di elemento (es. li, div, bento, ecc.).
n: Ã¨ un numero intero positivo, formula o parola chiave (es. 1, 2, even, odd, 2n+1...).

Esempio
li:nth-last-child(2)
â†’ seleziona il secondo li partendo dalla fine.
div:nth-last-child(1)
â†’ seleziona il primo figlio partendo dalla fine, se Ã¨ un div.
p:nth-last-child(odd)
â†’ Tutti i p in posizione dispari dalla fine
tr:nth-last-child(2n)
â†’ Ogni secondo tr dalla fine (2, 4, 6...)

------------------------------------------------------------------------------------------------------
| Selettore            | Conta da...   | Esempio                | Seleziona...                       |
| -------------------- | ------------- | ---------------------- | ---------------------------------- |
| `:nth-child(n)`      | Inizio (alto) | `li:nth-child(2)`      | Il secondo figlio `li` dall'inizio |
| `:nth-last-child(n)` | Fine (basso)  | `li:nth-last-child(2)` | Il secondo figlio `li` dalla fine  |
------------------------------------------------------------------------------------------------------

LIVELLO 20 => USO DI ":FIRST-OF-TYPE( )" (PRIMO DI QUEL TIPO)
-------------------------------------------------------
âœ… Soluzione:
apple:first-of-type

ğŸ“˜ Spiegazione elementare:
Questo selettore prende il primo elemento di un certo tipo (in questo caso apple) tra i fratelli, anche se non Ã¨ il primo in assoluto.
Nel tuo codice, il primo elemento Ã¨ un orange, ma il primo apple viene comunque selezionato.
ğŸ”§ Come funziona:
:first-of-type ignora tutti gli altri tipi di elementi.
Cerca il primo elemento del tipo indicato (come apple, p, li, div, ecc.) tra i figli dello stesso genitore.

Ãˆ diverso da :first-child, che prende il primo figlio in assoluto.

ğŸ§© Esempi:
p:first-of-type      /* primo paragrafo tra i figli */
div > span:first-of-type  /* primo <span> dentro ogni <div> */

ğŸŸ¢ Risultato:
Viene selezionato solo il primo apple, ignorando il fatto che Ã¨ il secondo figlio nel DOM.
Utile quando ci sono piÃ¹ tipi di elementi, ma si vuole stilizzare il primo di uno specifico tipo.

LIVELLO 21
-------------------------------------------------------
âœ… Soluzione:
plate:nth-of-type(even)

ğŸ“˜ Spiegazione elementare:
Questo selettore prende tutti i piatti (plate) in posizione pari: il 2Â°, 4Â°, 6Â°, ecc.
Nel gioco ci sono piÃ¹ <plate>, e devono essere selezionati solo quelli che si trovano in posizione 2, 4, ...
ğŸ”§ Come funziona:
:nth-of-type(even) seleziona tutti gli elementi dello stesso tipo (in questo caso plate) che sono in posizione pari rispetto ai fratelli dello stesso tipo.
L'indice parte da 1: quindi even corrisponde a 2Â°, 4Â°, 6Â°, ecc.
Si possono usare anche numeri o formule come :nth-of-type(2n) (equivalente a even), :nth-of-type(odd), :nth-of-type(3n+1), ecc.
ğŸŸ¢ Risultato:
Tutti i piatti in posizione pari (2Â°, 4Â°, 6Â°) vengono selezionati e evidenziati.

LIVELLO 22
-------------------------------------------------------
LIVELLO 23
-------------------------------------------------------
LIVELLO 24
-------------------------------------------------------
LIVELLO 25
-------------------------------------------------------
LIVELLO 26
-------------------------------------------------------
LIVELLO 27
-------------------------------------------------------
LIVELLO 28
-------------------------------------------------------
LIVELLO 29
-------------------------------------------------------
LIVELLO 30
-------------------------------------------------------
LIVELLO 31
-------------------------------------------------------
LIVELLO 32
-------------------------------------------------------
LIVELLO 33
-------------------------------------------------------
